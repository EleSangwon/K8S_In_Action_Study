# Chpater7 : ConfigMap과 스크릿 - 애플리케이션 설정 P297 ~
 
## 쿠버네티스에 설정 옵션을 전달하는 방법

### 컨테이너화된 애플리케이션 설정
```
쿠버네티스에서 실행 중인 애플리케이션에게 설정 데이터를 전달하기 전에 컨테이너된 애플리케이션이
일반적으로 어떻게 설정돼 있는지 살펴본다.

< 명령형 인자를 통한 전달 >
애플리케이션의 기본 설정을 변경하고 싶을 때 일반적으로 명령행 인자를 통해 애플리케이션을 설정해
새롭게 시작하게 된다.

그리고 나서 인자로 전달해야 할 설정 옵션 목록이 많아지면 그 설정을 설정 파일 형태로 변경하게 된다.

< 환경 변수를 통한 전달 >
컨테이너화된 애플리케이션에서 사용되는 설정 옵션을 전달하는 또 다른 방법은 환경 변수를 이용하는 것이다.
애플리케이션은 설정 파일이나 명령어 레벨의 인자를 읽는 대신 특정 환경 변수의 값을 검색한다.

< 환경 변수가 컨테이너에서 왜 인기가 많을까 ? >
도커 컨테이너 안에 있는 설정 파일을 사용하는 것은 까다로운 일이다. 설정 파일을 컨테이너 이미지 자체에 굽거나
파일이 들어 있는 볼륨을 컨테이너에 마운트해야 하기 때문이다.

파일을 이미지로 굽는 작업은 설정을 변경할 때마다 이미지를 다시 만들어야 하기 때문에 애플리케이션의
소스 코드에 설정을 하는 하드코딩과 유사하다.
```

## 설정 데이터를 저장하는 쿠버네티스 리소스 ConfigMap 
```
< configmap 사용 여부와 관계없이 애플리케이션 설정하는 방법 >
- 명령행 인자를 통해 컨테이너에 명령어 전달
- 각 컨테이너에 대한 사용자 정의 환경 변수 설정
- 특별한 볼륨 타입을 통해 컨테이너에 설정 파일을 마운트

애플리케이션 설정의 주된 포인트는 환경 간에 다양한 부분, 자주 변경되는 부분, 애플리케이션의 
소스 코드와 분리해야 하는 부분을 설정 옵션으로 유지하는 것이다.

< ConfigMap 소개 >
쿠버네티스는 설정 옵션을 configmap 이라는 별도의 객체로 분리할 수 있다.
이 객체는 간단한 문구부터 전체 설정 파일에 이르는 값을 갖는 키/값 쌍을 포합하는 맵이다.

애플리케이션은 configmap을 직접 읽거나 그것이 존재한다는 것을 알 필요가 없다.
맵의 내용은 대신 환경 변수 또는 볼륨의 파일로 컨테이너에 전달된다.

환경변수는 ${ENV_VAR} 구문을 사용해 명령행 인자에서 참조할 수 있기 때문에 
configmap 항목을 명령행 인자로 프로세스에 전달할 수도 있다.

애플리케이션은 필요한 경우 쿠버네티스 REST API 엔드포인트를 통해 configmap의 내용을 직접 읽을 수도 있지만
반드시 필요한 경우가 아니면 애플리케이션을 최대한 쿠버네티스에 종속적이지 않도록 유지해야 한다.

애플리케이션이 ConfigMap을 사용하는 방식에 관계없이 이와 같이 분리된 독립 실행형 객체를 설정하면 동일한 이름의
ConfigMap 에 대해 각각 다른 매니페스트(개발,테스트,QA)의 유지가 가능해진다.
```
![캡처1](https://user-images.githubusercontent.com/50174803/130223027-14aedda7-acd9-40ac-af47-acc10d89ebc4.jpg)

![캡처2](https://user-images.githubusercontent.com/50174803/130223567-72e75c58-d189-4eb2-9d0c-f31031a183dd.jpg)

## ConfigMap 생성
```
kubectl create configmap fortune-config --from-literal=sleep-interval=25

```
![캡처3](https://user-images.githubusercontent.com/50174803/130223796-d2396c56-df7b-44cb-88d7-fe13fdfbefd2.jpg)

## 옵션 결합
![캡처4](https://user-images.githubusercontent.com/50174803/130223910-88ccdce5-d78b-445d-b8ab-905f6510a969.jpg)
![캡처5](https://user-images.githubusercontent.com/50174803/130223918-e468434b-83fc-4083-8633-fdf8411eac4f.jpg)

## 컨테이너에 환경 변수로 ConfigMap 엔트리 전달하기

![캡처6](https://user-images.githubusercontent.com/50174803/130224072-45d6e344-97a6-4d04-86c3-de4748aef620.jpg)
![캡처7](https://user-images.githubusercontent.com/50174803/130224076-469d35f8-8d8d-4748-9c02-a9ea4c8894df.jpg)

## 존재하지 않는 ConfigMap의 참조
```
존재하지 않는 ConfigMap을 참조하는 컨테이너는 시작되지 않지만, 다른 컨테이너들은 정상적으로 시작된다.
누락한 ConfigMap을 생성하는 경우, 실패한 컨테이너는 포드를 다시 생성할 필요 없이 시작이 된다.

configMapKeyRef.optional: true 로 설정할 경우 ConfigMap 이 없어도 컨테이너가 시작된다.
```
## ConfigMap의 모든 항목을 한 번에 환경 변수로 전달하기
```
키가 여러개 있을 떄, envFrom 속성을 사용해 환경 변수로 모든 것을 노출시킬 수 있다.

```
![캡처8](https://user-images.githubusercontent.com/50174803/130224473-1050050a-0898-4a06-8ea9-f7bcd220485a.jpg)
![캡처9](https://user-images.githubusercontent.com/50174803/130224476-5d6f5fae-4a7f-4e4b-99f7-b8161f4f0f52.jpg)

## 시크릿으로 컨테이너에 민감한 데이터 전달하기

```
ConfigMap을 통해 전달하는 모든 정보는 안전하게 보관할 필요가 없는 일반적인 설정 데이터다.

설정에는 일반적으로 보안 유지가 필요한 자격 증명 및 개인 암호화 키 같은 중요한 정보가 포함될 수 있다.
```

## 시크릿 소개
```
중요한 정보를 저장하고 분류하기 위해 쿠버네티스는 시크릿이라고 하는 별도의 객체를 제공한다.
시크릿은 ConfigMap과 매우 흡사하며 키/값 쌍으로 사용할 수 있다.

쿠버네티스 내의 시크릿에 액세스해야 하는 포드를 실행하는 노드에만 배포하도록 하여 안전하게
유지할 수 있다.
```

## 시크릿과 ConfigMap 를 언제 사용해야 할까
```
민감하지 않은 일반 설정 데티터를 저장할 떄, ConfigMap을 사용한다.

본질적으로 민감한 데이터를 저장할 때 시크릿을 사용한다.

설정파일에 중요한 데이터와 중요하지 않은 데이터가 모두 포함돼 있으면 파일을 시크릿으로 저장한다.
```

## 기본 토큰 시크릿
```
모든 포드에는 자동으로 연결된 secret 볼륨이 있다.
kubectl get secret 을 사용해 해당 리소스를 나열하고 기본 토큰 시크릿을 찾을 수 있다.

시크릿에는 세 개의 항목(ca.crt, namespace, token)이 있다.
이 항목은 포드에서 쿠버네티스 API 서버와 안전하게 통신하기 위해 필요한 모든 것을 나타낸다.

이상적으로는 애플리케이션이 완전 쿠버네티스 독립적이 되길 원하지만 쿠버네티스와 직접 대화하는 것 외에
다른 방법이 없는 경우 secret 볼륨을 통해 제공되는 파일을 사용하게 된다.

```
![캡처10](https://user-images.githubusercontent.com/50174803/130225489-8412b5eb-6b20-4a6d-8d1f-a8500700bfb2.jpg)
![캡처11](https://user-images.githubusercontent.com/50174803/130225492-73850707-fa1b-4d5e-ac9e-89608dc0282a.jpg)

## ConfigMap과 시크릿 비교
```
스크릿의 내용은 Base64로 인코딩된 문자열로 표시하는 반면 ConfigMap의 내용은 일반 텍스트로 표시한다.
이것은 입력 내용을 설정하고 읽을 떄 인코드하고 디코드해야 하기 때문에 YAML과 JSON 형태로 시크릿을
작성하는 것이 좀 더 어렵다.
```
![캡처12](https://user-images.githubusercontent.com/50174803/130226347-eb182875-fcc6-4791-b81e-10eba01a9070.jpg)
![캡처13](https://user-images.githubusercontent.com/50174803/130226349-da5c5157-6183-445e-afb3-21efb084178f.jpg)

## 환경 변수로 시크릿의 엔트리 노출
```
볼륨을 사용하는 대신 ConfigMap을 사용한 것과 마찬가지로 환경 변수로 시크릿 엔트리의 개별 엔트리를 
노출할 수 있다. 
```
![캡처14](https://user-images.githubusercontent.com/50174803/130226722-ea782277-38f6-4d3d-8fd3-78f85d3e6627.jpg)
