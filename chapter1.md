# 쿠버네티스 인 액션 

## 쿠버네티스가 등장한 이유가 무엇일까?
```
거대한 모놀리식 애플리케이션이 마이크로서비스로 세분화되고 애플리케이션을
실행하는 인프라가 바뀌면서 개발방식과 배포 방식이 달라졌습니다.

또한 데이터 센터의 규모가 커지면서
전체 시스템을 원활하게 구성,관리,유지하는 것이 점점 어려워졌습니다.

효율적으로 리소스를 사용하여 하드웨어 비용을 최적화하려면 각 구성 요소를 어디에
배치해야 하는 지 파악하기 어렵고 수동으로 이 모든 작업을 수행하는 것은 더 어렵습니다.

그래서 서버의 구성 요소를 자동으로 스케줄링하고, 자동으로 구성 및 감독하고
오류를 처리하는 자동화가 필요해졌고 그로 인해 쿠버네티스가 등장하였습니다.
```

## 모놀리식 애플리케이션이란 ?
```
모놀리식 애플리케이션은 모든 것이 서로 강하게 결합해 구성되며 전체가 단일 OS프로세스로 실행되기 떄문에
하나의 개체로 개발,배포,관리해야 합니다.

애플리케이션을 조금만 변경해도 전체 애플리케이션을 다시 배포해야 하므로 시간이 지남에 따라
부분 간 경게가 모호해지고 점점 복잡해져 시스템 전체의 품질이 저하됩니다.
```

## 마이크로서비스란 ?
```
마이크로서비스는 서로 분리돼 있기 때문에 개별적으로 개발,배치,업데이트, 확장을
할 수 있습니다. 적은 수의 배포 가능한 구성 요소로된 시스템을 관리하는 것은 쉬운 일이지만
구성 요소의 수가 증가하면 배포 관련 조합의 수가 증가할 뿐만 아니라 구성 요소간 상호 종속성의 수도
복잡해져서 배포 관련 결정이 어려워집니다.
```

## 개발자와 시스템 관리자 입장에서 본 쿠버네티스의 장점
```
개발자는 애플리케이션을 배포하고 실행하는 단일 플랫폼으로써 쿠버네티스를 사용하여
실제 하드웨어를 추상화하고 노출함으로써 시스템 관리자의 도움 없이도 애플리케이션을 구성&배포할 수 있습니다.

시스템 관리자는 실제로 하드웨어에서 실행되고 있는 애플리케이션을 몰라도
기본 인프라를 유지하고 가동하는 데 집중할 수 있습니다.
```

## 리눅스 컨테이너 기술
```
쿠버네티스는 리눅스 컨테이너 기술을 사용해 실행 중인 애플리케이션을 격리한다.
이 기능을 사용하면, 같은 호스트 시스템에서 여러 서비스를 실행할 수 있으며 
동시에 각 서비스에게 각기 다른 환경을 만들어줄 뿐만 아니라 가상머신과 유사하지만
가상머신에 비해 오버헤드가 훨씬 적다.
```

## 가상머신과 컨테이너 비교
```
컨테이너는 가상머신에 비해 가볍기 떄문에 동일한 하드웨어에서 더 많은 소프트웨어 
구성요소를 실행할 수 있다.
또한 컨테이너는 호스트 OS에서 실행하는 단일 격리된 프로세스 이상으로 리소스를 소비하지 않고
애플리케이션에서 사용하는 리소스만 사용하여 더 이상의 프로세스의 오버헤드가 발생하지 않는다.
컨테이너는 모두 동일한 커널 상에서 시스템을 호출하므로 보안 위험의 염려가 있다.

가상머신은 각 하드웨어가 자체 시스템 프로세스 집합을 실행해야 하기 때문에 자체 프로세스에서 
소비되는 것 외에도 컴퓨팅 리소스가 필요하다.
가상머신의 장점은 각 가상머신이 자체 리눅스 커널 위에서 실행되기 때문에 완전히 분리시킬 수 있다.

동일한 시스템에서 더 많은 프로세스를 격리해 실행하려면 오버헤드가 낮은 
컨테이너를 선택하는 것이 좋다.

컨테이너를 실행하면 가상머신의 경우처럼 부팅을 할 필요가 없다.
컨테이너가 기동되면 프로세스는 즉시 시작된다.
```

## 컨테이너 격리를 가능하게하는 매커니즘
```
- 첫 번째 매커니즘

각 프로세스가 파일,프로세스, 네트워크 인터페이스, 호스트 이름 등 시스템에 독립 뷰를 제공하는
리눅스 네임스페이스

- 두 번쨰 매커니즘

프로세스가 소비할 수 있는 리소스의 양을 제한할 수 있는 리눅스
컨트롤 그룹 cgroups
```

## 도커란?
```
도커는 애플리케이션의 패키징,배포,실행 플랫폼이다.
애플리케이션을 전체 환경과 함께 패키징할 수 있다.

도커를 사용해 패키지를 중앙 스토리지로 전송한 후, 도커를 실행하는
모든 시스템에 패키지를 전송할 수 있다.
```

## 도커의 주요 개념
```
- 이미지 
애플리케이션과 환경을 패키지로 묶는 것
여기에는 애플리케이션에서 사용할 수 있는 파일 시스템과 이미지가 실행될 떄 실행해야 하는
실행파일의 경로 등의 메타데이터가 있다.

- 레지스트리
도커 이미지를 저장하고 공유할 수 있는 스토리지

- 컨테이너
도커 기반 컨테이너 이미지에서 생성된 일반적인 형태의 리눅스 컨테이너
실행 중인 컨테이너는 도커에서 실행하는 호스트에서 실행되는 프로세스지만
호스트와 호스트에서 실행되는 모든 프로세스 간에 완전히 분리돼 있다.
프로세스는 리소스가 제한되어 있어 할당된 리소스만 엑세스하고 사용할 수 있다.
```

## 컨테이너의 한계
```
컨테이너화된 애플리케이션이 특정 커널 버전을 요구한다면 모든 시스템에서
작동하지 않을 수 있다.
컨테이너는 가상머신에 비해 훨씬 가볍지만 컨테이너 내부에서 실행되는 애플리케이션에
제약이 있다.
각 가상머신은 자체 커널을 실행하기 때문에 가상머신에는 이런 제약이 없다.
```

## 쿠버네티스 클러스터 아키텍처
```
- 컨트롤 플레인
클러스터를 관리하고 클러스터의 기능을 실행한다.
클러스터의 상태를 유지하고 제어하지만 애플리케이션을 실행하지는 않는다.

- 구성요소
사용자와 컨트롤 플레인과 통신하는 쿠버네티스 API 서버

애플리케이션을 예약하는 스케줄러

구성 요소 복제, 워커노드 추적, 노드 장애처리 등 클러스터 수준 기능을
실행하는 컨트롤러 매니저

etcd 클러스터 구성을 지속적으로 저장하는 안정적인 분산 데이터 스토리지

- 노드
워커노드는 컨테이너화된 애플리케이션을 실행하는 시스템

- 구성요소
컨테이너를 실행하는 도커, rkt 또는 컨테이너 런타임

API 서버와 통신하고 노드에서 컨테이너 관리하는 kubelet 

애플리케이션 구성요소 간에 네트워크 트래픽을 분산하는
쿠버네티스 서비스 프록시 (kube-proxy)
```

## 실행중인 컨테이너 유지

```
애플리케이션이 실행되면 쿠버네티스느 애플리케이션의 배포된 상태가 사용자가 제공한
디스크립션과 일치하는 지 지속적으로 확인한다.
```

## 복제본 수 확장
```
애플리케이션이 실행되는 동안 복사본의 수를 늘리거나 줄일 지 결정할 수 있다.
최적의 복제본의 수를 결정하는 일은 쿠버네티스에 맡길 수도 있다.
CPU 부하, 메모리 사용량, 초당쿼리, 애플리케이션에서 노출하는 그 외의 메트릭 같은
실시간 매트릭에 따라 숫자를 자동으로 조절
```

## 쿠버네티스의 장점
```
쿠버네티스가 모든 서버에 배포된 경우 운영 팀은 더이상 애플리케이션을 배포할 필요가 없다.
컨테이너화된 애플리케이션에는 이미 필요한 모든 항목이 포함돼 있기 때문에 시스템 관리자는 
애플리케이션을 배포하고 실행하기 위해 아무것도 설치할 필요가 없다.

- 애플리케이션 배포 단순화
쿠버네티스는 모든 워커 노드를 단일 배포 플랫폼으로 제공하므로 애플리케이션 개발자는 직접
애플리케이션을 배포할 수 있고, 클러스터를 구성하는 서버에 대해 알 필요가 없다.

- 하드웨어 활용도 높이기
서버에 애플리케이션을 수동으로 실행하는 대신 쿠버네티스를 셋업하고,
애플리케이션을 실행하도록 하면 인프라에서 애플리케이션을 분리할 수 있다.

쿠버네티스에 애플리케이션을 실행하도록 지시하면 애플리케이션의 리소스
요구사항에 대한 설명과 각 노드에서 사용 가능한 리소스에 따라 애플리케이션을 실행할 
가장 적합한 노드를 선택하게 된다.

- 상태확인 및 자가 치유
클러스터를 통해 애플리케이션을 이동할 수 있는 시스템은 서버 장애 시에도 유용하다.

쿠버네티스는 애플리케이션 구성 요소와 실행되는 노드를 모니터링하고 노드 장애 발생 시
다른 노드로 일정을 자동으로 재조정한다.

- 오토 스케일링
쿠버네티스는 각 애플리케이션에서 사용하는 리소스를 모니터링하고 각 애플리케이션에서
실행되는 인스턴스 수를 계속 조정하도록 지시할 수 있다.

클라우드 인프라에서 실행되는 경우 쿠버네티스는 배포된 애플리케이션의 요구사항에 따라
전체 클러스터 크기를 자동으로 확대 또는  축소할 수 있다.
```

